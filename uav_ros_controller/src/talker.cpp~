#include "ros/ros.h"
#include "std_msgs/String.h"

#include <sstream>
#include <iostream>
#include <fstream>
#include <stdlib.h>
#include "geometry_msgs/Twist.h"
#include "sensor_msgs/NavSatFix.h"
#include "sensor_msgs/LaserScan.h"


#include "subpub_list.h"
// #include <physics/physics.hh>

using namespace std;
using namespace ros;

// std::string filename;
// std::ofstream ofs("gazebo_ros_op.txt");


bool is_empty(ifstream& pFile)
{
    return pFile.peek() == ifstream::traits_type::eof();
}
/home/dasc/catkin_ws/src/project590/src

int main(int argc, char **argv)
{
  	std::cout <<"start"<< std::endl;

    std::fstream DataInput;
    DataInput.open("/home/dasc/catkin_ws/src/project590/src/data/datainput.txt",ios::out); 
    cout << "DataInput file: " << DataInput <<endl;

    ros::init(argc, argv, "talker");

    // string namelist  = physics::World::Name ();


    const int num_of_quads = 5;
    
    ros::NodeHandle n;
    geometry_msgs::Twist odom_msg[num_of_quads];

    ros::Publisher chatter_pub[num_of_quads];
    ros::Subscriber GPSsub[num_of_quads];  



    UAV_list uav_net;


    // UAV quad[num_of_quads];
    for (int i = 0; i<num_of_quads;i++)
    {
        chatter_pub[i] = n.advertise<geometry_msgs::Twist>(pub(i), 1);

        UAV t(i);
        uav_net.insert(t);
        GPSsub[i] = n.subscribe(sub(i), 1, &UAV::callback,&(uav_net.elts[i]));
    }


    ros::Rate loop_rate(10);

    int count = 0;

    ifstream vel_input("/home/dasc/catkin_ws/src/project590/src/data/vel_input.txt");
    cout << "vel_input file: " << vel_input <<endl;


    while (ros::ok())
    {
        if (!is_empty(vel_input))
        {

            string line;
            vector<double> vel_list;
            getline(vel_input, line);
            istringstream vel_ary(line);

            for (int i = 0; i < 3; i++)
            {
                double current_data;
                vel_ary >> current_data;
                vel_list.push_back(current_data);
            }

            for(int i = 0; i < num_of_quads; i++)
            {
                // odom_msg[0].linear.x = vel_list[i*3];
                // odom_msg[0].linear.y = vel_list[i*3 +1];
                // odom_msg[0].linear.z = vel_list[i*3 +2];

                odom_msg[i].linear.x = vel_list[0];
                odom_msg[i].linear.y = vel_list[1];
                odom_msg[i].linear.z = vel_list[2];

                chatter_pub[i].publish(odom_msg[i]);

            }
  
        }
        else
        {
            // continue;
        }

        FILE* fp_pos = fopen("gps_output.txt", "w");
        fclose(fp_pos);

        ofstream GPS_output("/home/dasc/catkin_ws/src/project590/src/data/gps_output.txt");  
        // cout << "gps_output file: " << GPS_output <<endl;
        for(int i = 0; i < num_of_quads; i++)
        {
                GPS_output << uav_net.elts[i].latitude <<" "
                      << uav_net.elts[i].longitude <<" "
                            << uav_net.elts[i].altitude <<std::endl;
        }    
        ros::spinOnce();
        loop_rate.sleep();
        
    }


    return 0;
}
